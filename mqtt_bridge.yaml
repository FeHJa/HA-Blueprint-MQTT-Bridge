blueprint:
  name: MQTT Entity Bridge with Shared Discovery Federation (stable, no availability)
  description: >
    Publishes selected entities with MQTT Discovery to a shared prefix (for cross-HA federation),
    and listens to discovery configs on that shared prefix, forwarding them to your local discovery topic.
    Uses retained discovery/state and normalized prefixes. Avoids invalid device_class/UoM when missing.
  author: Felix, Mistral & ChatGPT
  domain: automation

  input:
    entities:
      name: Entities to bridge
      description: "Select all entities (sensor, binary_sensor, input_boolean, etc.) you want to publish."
      selector:
        entity:
          multiple: true
    shared_discovery_prefix:
      name: Shared Discovery Prefix
      description: "The shared prefix for MQTT discovery configs, e.g., 'share/homeassistant/'. (Note: the MQTT trigger below is hard-coded and must match this.)"
      default: "share/homeassistant/"
      selector:
        text:
    local_discovery_prefix:
      name: Local Discovery Prefix
      description: "Usually 'homeassistant'."
      default: "homeassistant"
      selector:
        text:
    sensor_value_prefix:
      name: Sensor Value Prefix
      description: "The prefix for MQTT sensor values, e.g., 'share/jakob/'."
      default: "share/jakob/"
      selector:
        text:
    time_pattern:
      name: Time pattern
      description: "Specify how often the topics should be updated, e.g., every minute ('/1')."
      default: "/1"
      selector:
        text:
    bridge_name:
      name: Bridge Name
      description: "Name for the device in discovery configs."
      default: "Bridge Jakob"
      selector:
        text:

trigger:
  - platform: state
    entity_id: !input entities
  - platform: time_pattern
    minutes: !input time_pattern
  - platform: mqtt
    # IMPORTANT: must match your shared_discovery_prefix; HA cannot template trigger topics
    topic: "share/homeassistant/+/+/config"
  - platform: event
    event_type: force_republish_sensors  # Custom event to force republishing

variables:
  shared_discovery_prefix: !input shared_discovery_prefix
  local_discovery_prefix: !input local_discovery_prefix
  sensor_value_prefix: !input sensor_value_prefix
  entities: !input entities
  bridge_name: !input bridge_name

  # Normalize prefixes to guarantee exactly one trailing slash where needed
  shared_prefix_norm: "{{ (shared_discovery_prefix | trim('/')) ~ '/' }}"
  sensor_prefix_norm: "{{ (sensor_value_prefix | trim('/')) ~ '/' }}"
  local_prefix_norm: "{{ (local_discovery_prefix | trim('/')) }}"  # HA's local doesn't need trailing slash

  slug_bridge_name: "{{ bridge_name | lower | replace(' ', '_') | regex_replace('[^a-z0-9_]', '') }}"
  random_delay: "{{ range(0, 10) | random }}"

action:
  - choose:
      - conditions:
          - condition: template
            value_template: "{{ trigger.platform in ['time_pattern', 'state', 'event'] }}"
        sequence:
          - delay: "{{ '00:00:' ~ random_delay }}"
          - choose:
              - conditions:
                  - condition: template
                    value_template: "{{ trigger.platform in ['time_pattern', 'event'] }}"
                sequence:
                  - repeat:
                      for_each: "{{ entities }}"
                      sequence:
                        - variables:
                            object_id: "{{ repeat.item.split('.')[-1] }}"
                            state_topic: "{{ sensor_prefix_norm }}sensor/{{ object_id }}"
                            disc_topic: "{{ shared_prefix_norm }}sensor/{{ object_id }}/config"

                            # Prefer actual attributes; only guess if attribute is truly missing/None
                            _dc: "{{ state_attr(repeat.item, 'device_class') }}"
                            device_class: >-
                              {% if _dc is not none %}{{ _dc }}{% else %}
                                {% if 'temperature' in repeat.item %}temperature
                                {% elif 'humidity' in repeat.item %}humidity
                                {% elif 'pressure' in repeat.item %}pressure
                                {% elif 'power' in repeat.item %}power
                                {% elif 'energy' in repeat.item %}energy
                                {% elif 'current' in repeat.item %}current
                                {% elif 'voltage' in repeat.item %}voltage
                                {% elif 'light' in repeat.item %}illuminance
                                {% else %}__none__{% endif %}
                              {% endif %}
                            _uom: "{{ state_attr(repeat.item, 'unit_of_measurement') }}"
                            unit_of_measurement: >-
                              {% if _uom is not none %}{{ _uom }}{% else %}
                                {% if 'temperature' in repeat.item %}°C
                                {% elif 'humidity' in repeat.item %}%
                                {% elif 'pressure' in repeat.item %}hPa
                                {% elif 'power' in repeat.item %}W
                                {% elif 'energy' in repeat.item %}kWh
                                {% elif 'current' in repeat.item %}A
                                {% elif 'voltage' in repeat.item %}V
                                {% elif 'light' in repeat.item %}lx
                                {% else %}__none__{% endif %}
                              {% endif %}

                        - service: mqtt.publish
                          data:
                            topic: "{{ disc_topic }}"
                            retain: true
                            payload: >-
                              {
                                "name": "{{ state_attr(repeat.item, 'friendly_name') | default(object_id.replace('_', ' ').title(), true) }}",
                                "state_topic": "{{ state_topic }}",
                                "unique_id": "{{ slug_bridge_name }}::{{ repeat.item }}"{% if device_class != '__none__' %},
                                "device_class": "{{ device_class }}"{% endif %}{% if unit_of_measurement != '__none__' %},
                                "unit_of_measurement": "{{ unit_of_measurement }}"{% endif %},
                                "bridge_id": "{{ slug_bridge_name }}",
                                "device": {
                                  "identifiers": ["{{ slug_bridge_name }}"],
                                  "name": "{{ bridge_name }}",
                                  "sw_version": "1.0.3"
                                }
                              }

                        - service: mqtt.publish
                          data:
                            topic: "{{ state_topic }}"
                            payload: "{{ states(repeat.item) }}"
                            retain: true

            default:
              - variables:
                  object_id: "{{ trigger.entity_id.split('.')[-1] }}"
                  state_topic: "{{ sensor_prefix_norm }}sensor/{{ object_id }}"
                  disc_topic: "{{ shared_prefix_norm }}sensor/{{ object_id }}/config"
                  _dc: "{{ state_attr(trigger.entity_id, 'device_class') }}"
                  device_class: >-
                    {% if _dc is not none %}{{ _dc }}{% else %}
                      {% if 'temperature' in trigger.entity_id %}temperature
                      {% elif 'humidity' in trigger.entity_id %}humidity
                      {% elif 'pressure' in trigger.entity_id %}pressure
                      {% elif 'power' in trigger.entity_id %}power
                      {% elif 'energy' in trigger.entity_id %}energy
                      {% elif 'current' in trigger.entity_id %}current
                      {% elif 'voltage' in trigger.entity_id %}voltage
                      {% elif 'light' in trigger.entity_id %}illuminance
                      {% else %}__none__{% endif %}
                    {% endif %}
                  _uom: "{{ state_attr(trigger.entity_id, 'unit_of_measurement') }}"
                  unit_of_measurement: >-
                    {% if _uom is not none %}{{ _uom }}{% else %}
                      {% if 'temperature' in trigger.entity_id %}°C
                      {% elif 'humidity' in trigger.entity_id %}%
                      {% elif 'pressure' in trigger.entity_id %}hPa
                      {% elif 'power' in trigger.entity_id %}W
                      {% elif 'energy' in trigger.entity_id %}kWh
                      {% elif 'current' in trigger.entity_id %}A
                      {% elif 'voltage' in trigger.entity_id %}V
                      {% elif 'light' in trigger.entity_id %}lx
                      {% else %}__none__{% endif %}
                    {% endif %}

              - service: mqtt.publish
                data:
                  topic: "{{ disc_topic }}"
                  retain: true
                  payload: >-
                    {
                      "name": "{{ state_attr(trigger.entity_id, 'friendly_name') | default(object_id.replace('_', ' ').title(), true) }}",
                      "state_topic": "{{ state_topic }}",
                      "unique_id": "{{ slug_bridge_name }}::{{ trigger.entity_id }}"{% if device_class != '__none__' %},
                      "device_class": "{{ device_class }}"{% endif %}{% if unit_of_measurement != '__none__' %},
                      "unit_of_measurement": "{{ unit_of_measurement }}"{% endif %},
                      "bridge_id": "{{ slug_bridge_name }}",
                      "device": {
                        "identifiers": ["{{ slug_bridge_name }}"],
                        "name": "{{ bridge_name }}",
                        "sw_version": "1.0.3"
                      }
                    }

              - service: mqtt.publish
                data:
                  topic: "{{ state_topic }}"
                  payload: "{{ trigger.to_state.state }}"
                  retain: true

      - conditions:
          - condition: template
            value_template: >
              {{ trigger.platform == 'mqtt'
                 and trigger.topic.endswith('/config')
                 and trigger.topic.startswith(shared_prefix_norm) }}
        sequence:
          - variables:
              topic_parts: "{{ trigger.topic.split('/') }}"
              prefix_len: "{{ shared_prefix_norm.split('/') | select('ne', '') | list | length }}"
              component: "{{ topic_parts[prefix_len] if topic_parts|length > prefix_len else '' }}"
              object_id: "{{ topic_parts[prefix_len+1] if topic_parts|length > prefix_len+1 else '' }}"
              config_marker: "{{ topic_parts[prefix_len+2] if topic_parts|length > prefix_len+2 else '' }}"
              forward_topic: "{{ local_prefix_norm }}/{{ component }}/{{ object_id }}/config"
              payload_len: "{{ trigger.payload | length }}"
              payload_dict: "{{ trigger.payload | from_json if trigger.payload | length > 0 else {} }}"
              uid: "{{ (payload_dict.unique_id | default('')) | string }}"
              is_own: >-
                {{ payload_dict.bridge_id | default('') == slug_bridge_name
                   or uid.startswith(slug_bridge_name ~ '::')
                   or uid.startswith(slug_bridge_name ~ '.') }}
          - condition: template
            value_template: >
              {{ (component | length > 0)
                 and (object_id | length > 0)
                 and (config_marker == 'config')
                 and (not is_own) }}
          - service: mqtt.publish
            data:
              topic: "{{ forward_topic }}"
              payload: "{{ trigger.payload }}"
              retain: true

mode: parallel
max: 50
